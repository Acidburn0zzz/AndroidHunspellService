Index: jni/hunspell/hunspell.cxx
===================================================================
--- jni/hunspell/hunspell.cxx	(revision 99)
+++ jni/hunspell/hunspell.cxx	(working copy)
@@ -59,7 +59,11 @@
     wordbreak = pAMgr->get_breaktable();
 
     /* and finally set up the suggestion manager */
+#ifdef HUNSPELL_CHROME_CLIENT
+    pSMgr = new SuggestMgr(bdict_reader, try_string, MAXSUGGESTION, pAMgr);
+#else
     pSMgr = new SuggestMgr(try_string, MAXSUGGESTION, pAMgr);
+#endif
     if (try_string) free(try_string);
 }
 
Index: jni/hunspell/suggestmgr.cxx
===================================================================
--- jni/hunspell/suggestmgr.cxx	(revision 99)
+++ jni/hunspell/suggestmgr.cxx	(working copy)
@@ -104,9 +104,18 @@
 }  // namespace
 #endif
 
+
+#ifdef HUNSPELL_CHROME_CLIENT
+SuggestMgr::SuggestMgr(hunspell::BDictReader* reader,
+                       const char * tryme, int maxn, 
+                       AffixMgr * aptr)
+{
+  bdict_reader = reader;
+#else
 SuggestMgr::SuggestMgr(const char * tryme, int maxn, 
                        AffixMgr * aptr)
 {
+#endif
 
   // register affix manager and check in string of chars to 
   // try when building candidate suggestions
@@ -499,6 +508,49 @@
   int lenr, lenp;
   int wl = strlen(word);
   if (wl < 2 || ! pAMgr) return ns;
+  
+#ifdef HUNSPELL_CHROME_CLIENT
+  const char *pattern, *pattern2;
+  hunspell::ReplacementIterator iterator = bdict_reader->GetReplacementIterator();
+  while (iterator.GetNext(&pattern, &pattern2)) {
+      r = word;
+      lenr = strlen(pattern2);
+      lenp = strlen(pattern);
+      
+      // search every occurence of the pattern in the word
+      while ((r=strstr(r, pattern)) != NULL) {
+          strcpy(candidate, word);
+          if (r-word + lenr + strlen(r+lenp) >= MAXLNLEN) break;
+          strcpy(candidate+(r-word), pattern2);
+          strcpy(candidate+(r-word)+lenr, r+lenp);
+          ns = testsug(wlst, candidate, wl-lenp+lenr, ns, cpdsuggest, NULL, NULL);
+          if (ns == -1) return -1;
+          // check REP suggestions with space
+          char * sp = strchr(candidate, ' ');
+          if (sp) {
+            char * prev = candidate;
+            while (sp) {
+              *sp = '\0';
+              if (checkword(prev, strlen(prev), 0, NULL, NULL)) {
+                int oldns = ns;
+                *sp = ' ';
+                ns = testsug(wlst, sp + 1, strlen(sp + 1), ns, cpdsuggest, NULL, NULL);
+                if (ns == -1) return -1;
+                if (oldns < ns) {
+                  free(wlst[ns - 1]);
+                  wlst[ns - 1] = mystrdup(candidate);
+                  if (!wlst[ns - 1]) return -1;
+                }
+              }
+              *sp = ' ';
+              prev = sp + 1;
+              sp = strchr(prev, ' ');
+            }
+          }
+          r++; // search for the next letter
+    }
+  }
+#else
   int numrep = pAMgr->get_numrep();
   struct replentry* reptable = pAMgr->get_reptable();
   if (reptable==NULL) return ns;
@@ -540,6 +592,7 @@
           r++; // search for the next letter
       }
    }
+#endif
    return ns;
 }
 
Index: jni/hunspell/suggestmgr.hxx
===================================================================
--- jni/hunspell/suggestmgr.hxx	(revision 99)
+++ jni/hunspell/suggestmgr.hxx	(working copy)
@@ -52,7 +52,11 @@
 
 
 public:
+#ifdef HUNSPELL_CHROME_CLIENT
+  SuggestMgr(hunspell::BDictReader* reader, const char * tryme, int maxn, AffixMgr *aptr);
+#else
   SuggestMgr(const char * tryme, int maxn, AffixMgr *aptr);
+#endif
   ~SuggestMgr();
 
   int suggest(char*** slst, const char * word, int nsug, int * onlycmpdsug);
@@ -66,6 +70,10 @@
   char * suggest_morph_for_spelling_error(const char * word);
 
 private:
+#ifdef HUNSPELL_CHROME_CLIENT
+   // Not owned by us, owned by the Hunspell object.
+   hunspell::BDictReader* bdict_reader;
+#endif
    int testsug(char** wlst, const char * candidate, int wl, int ns, int cpdsuggest,
      int * timer, clock_t * timelimit);
    int checkword(const char *, int, int, int *, clock_t *);
